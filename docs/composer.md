# Использование Composer

[Установка Composer на OpenServer](https://github.com/epixx/php/blob/master/docs/openserver/composer.md)

## Общая информация

Composer позволяет автоматически загружать файлы и классы вашего проекта, а так же устанавливать внешние зависимости (нужные вам библиотеки).

## Пример

Далее для разбора будет использован пример из [examples/composer](https://github.com/epixx/php/tree/master/examples/composer).

### Создаем `composer.json`

Сначала в папке проекта необходимо создать файл `composer.json`, у нас он такого вида:

```json
{
	"require": {
		"jbroadway/urlify": "1.0.*"
	},
	"autoload": {
		"files": [
			"config/init.php"
		],
		"psr-4": {
			"Epic\\Controllers\\": "controllers",
			"Epic\\Models\\": "models"
		}
	}
}
```

#### `require`

В `require` указываются внешние зависимости, на примере простейшей библиотеки [URLify](https://github.com/jbroadway/urlify). Необходимая библиотека для такой загрузки и подключения к вашему проекту должна быть на [Packagist](https://packagist.org/explore/). Composer сам ищет и загружает её в папку vendor. Как понимаете, это необязательно, тут для примера загрузки внешних библиотек.

#### `autoload`

В `autoload` указываются файлы и классы для автозагрузки. Файлы указываются в `files`, классы в `psr-4` (в нашем случае, в соответствии с [PSR-4](http://www.php-fig.org/psr/psr-4/)). Отличие в автозагрузке файлов и классов в том, что указанные в `files` файлы будут подключены в любом случае, в то время как классы **только при непосредственном обращении** к конкретному классу (при создании экземпляра класса).

#### Расположение и название файлов для `psr-4`

Мы указываем пространство (подпространство) имен и соответствующее ему расположение классов. Важно чтобы названия файлов были такими же, как и названия классов (регистр учитывается)! То есть файл с классом `UserController`, с объявленным подпространством имен `Epic\Controllers` должен называться `UserController.php` и находиться в папке `controllers`.

### Структура нашего проекта

В нашем проекте объявлено пространство имен `Epic` в "главном" файле `index.php`. Так же у нас есть контроллеры `HomeController` и `UserController`, унаследованные от базового абстрактного класса `Controller`, все они находятся в папке `controllers` и имеют подпространство имен `Epic\Controllers`.

Аналогично мы имеем базовый абстрактный класс `Model` и его потомков `Message` и `User`, которые находятся в папке `models` и имеют подпространство имен `Epic\Models`.

Создавать объекты мы должны, обращаясь к классу по его подпространству, например `new Controllers\HomeController`. Если бы в `index.php` не было объявлено пространство имен `Epic`, то тогда создавать экземпляр класса пришлось бы с указанием полного "пути" - `new Epic\Controllers\HomeController`. А если бы в `index.php` было объявлено иное пространство имен, например, `MyName`, то - `new \Epic\Controllers\HomeController`, явно указывая глобальное пространство при помощи обратной косой черты в начале.

Если вы указываете в стартовом файле (`index.php`) свое пространство имен, то все классы должны соответствовать ему по иерархии, либо явно указываться глобально. То есть теперь для создания подключения к базе данных при помощи известного нам класса `PDO`, нам нужно использовать `new \PDO`.

### Composer install

После создания файла `composer.json` и указания в нем соответствующих файлов и классов (пространств), мы должны в папке проекта, там где непосредственно расположен `composer.json`, в консоли выполнить:

```
composer install
```

Если файл `composer.json` меняется по ходу разработки, то после его изменения нужно выполнить в консоли команду:

```
composer update
```

Эти команды дают знать Composer, что нужно проверить новые зависимости, загрузить их при необходимости, а так же создать или обновить соответствующие файлы для автозагрузки. Всё, что требуется от нас - подключить к проекту файл `vendor/autoload.php`.

### Что происходит в `index.php`

```php
<?php
namespace Epic;

require 'vendor/autoload.php';

$controller = new Controllers\HomeController();
$controller->model();

$urlfy = \URLify::filter('Маленький пушистый зайчик');
echo 'Результат вызова библиотеки URLify: ' . $urlfy;
```

Самое главное - мы подключаем файл `vendor/autoload.php`, который и обеспечивает нам всю магию автоматической загрузки файлов и классов.

Далее мы создаем экземпляр класса `HomeController` и вызываем у него метод `model()`, в котором, в свою очередь, создается экземпляр класса `Message`.

Затем мы обращаемся к нашей внешней библиотеке, URLify, указывая глобальное пространство имен. После выполнения `composer install` эта библиотека была загружена в папку vendor и так же добавлена в автозагрузку.

Как сами видите из примеров, классы и методы простейшие и содержат лишь вывод на экран текущего действия. Так же в файлах с классами есть вывод строки, что подключен сам файл, для наглядности происходящего. В браузере будет:

```
Подключен файл config/init.php
Подключен файл controllers/Controller.php
Подключен файл controllers/HomeController.php
Вызван конструктор абстрактного класса Controller
Вызван конструктор класса HomeController
Вызван метод model у класса HomeController
Подключен файл models/Model.php
Подключен файл models/Message.php
Вызван конструктор абстрактного класса Model
Вызван конструктор класса Message
Результат вызова библиотеки URLify: malenkij-pushistyj-zajchik
```

Сначала был подключен файл `config/init.php`, он будет подключен в любом случае, так как указан в `files` в `composer.json`.

Затем мы создали экземпляр класса `HomeController`, автозагрузчик нашел его в соответствии с указаниями в `composer.json` в папке `controllers`. Обнаружив, что класс унаследован от `Controller`, он нашел и подключил сначала файл с родительским классом.

Вызывается конструктор `Controller`, как и указано в конструкторе `HomeController` (`parent::__construct();`), а затем и собственный конструктор.

Далее мы обращаемся к методу `model()`, в котором создается объект `Message`. Тут аналогично, сначала подключается файл с родительским классом, затем уже с классом `Message`. То же и с конструкторами.

Ну и напоследок выводится результат работы `URLify`.

Файлы `controllers/UserController.php` и `models/User.php` подключены не были, так как обращения к этим классам не выполнялось.

### use

В файлах с классами контроллеров используется `use Epic\Models` для обращения к `Message` и `User`. `use Epic\Models` говорит о том, что классы `Message` и `User` нужно искать в другом подпространстве имен, ведь сейчас мы фактически находимся в `Epic\Controllers`, а значит нужно либо явно указывать `\Epic\Models\Message` и `\Epic\Models\User`, либо использовать `use Epic\Models` и создавать экземпляры при помощи `Models\Message` и `Models\User`.

### Динамическое имя класса

Если мы формируем название контроллера динамически (например, получая из адресной строки), то тогда нужно использовать полное описание подпространства имен:

```php
<?php
namespace Epic;

require 'vendor/autoload.php';

$controllerName = isset($_GET['action'])
    ? ucfirst($_GET['action']) . 'Controller'
    : 'HomeController';

$controllerPath = 'Epic\\Controllers\\'.$controllerName;
$controller = new $controllerPath();
$controller->model();

$urlfy = \URLify::filter('Маленький пушистый зайчик');
echo 'Результат вызова библиотеки URLify: ' . $urlfy;
```

## Дополнительно

- [Документация Composer](https://getcomposer.org/doc/)
- [PHP Standards Recommendations](http://www.php-fig.org/psr/)
- [Пространства имен](http://php.net/manual/ru/language.namespaces.php)